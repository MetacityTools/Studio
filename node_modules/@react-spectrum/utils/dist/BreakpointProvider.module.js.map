{"mappings":";;;;;AAcA,MAAM,8CAAU,CAAA,GAAA,YAAI,EAAE,aAAa,CAAoB;AACvD,8BAAQ,WAAW,GAAG;AAOf,SAAS,0CAAmB,KAA8B;IAC/D,IAAI,YACF,QAAQ,sBACR,kBAAkB,EACnB,GAAG;IACJ,qBACE,gCAAC,8BAAQ,QAAQ;QACf,OAAO;gCAAC;QAAkB;OACzB;AAGP;AAEO,SAAS,0CAAsB,WAAwB;IAC5D,IAAI,UAAU,OAAO,OAAO,CAAC,aAAa,IAAI,CAAC,CAAC,GAAG,OAAO,EAAE,GAAG,OAAO,GAAK,SAAS;IACpF,IAAI,oBAAoB,QAAQ,GAAG,CAAC,CAAC,GAAG,MAAM,GAAK,CAAC,YAAY,EAAE,MAAM,GAAG,CAAC;IAE5E,IAAI,qBAAqB,OAAO,WAAW,eAAe,OAAO,OAAO,UAAU,KAAK;IACvF,IAAI,uBAAuB;QACzB,IAAI,UAAU,EAAE;QAChB,IAAK,IAAI,KAAK,kBAAmB;YAC/B,IAAI,QAAQ,iBAAiB,CAAC,EAAE;YAChC,IAAI,OAAO,UAAU,CAAC,OAAO,OAAO,EAClC,QAAQ,IAAI,CAAC,OAAO,CAAC,EAAE,CAAC,EAAE;QAE9B;QACA,QAAQ,IAAI,CAAC;QACb,OAAO;IACT;IAEA,IAAI,CAAC,YAAY,cAAc,GAAG,CAAA,GAAA,eAAO,EAAE,IACzC,qBACI,yBACA;YAAC;SAAO;IAGd,CAAA,GAAA,gBAAQ,EAAE;QACR,IAAI,CAAC,oBACH;QAGF,IAAI,WAAW;YACb,MAAM,oBAAoB;YAE1B,cAAc,CAAA;gBACZ,IAAI,0BAA0B,MAAM,KAAK,kBAAkB,MAAM,IAC/D,0BAA0B,IAAI,CAAC,CAAC,YAAY,MAAQ,eAAe,iBAAiB,CAAC,IAAI,GACzF,OAAO;uBAAI;iBAAkB,EAAE,2CAA2C;gBAG5E,OAAO;YACT;QACF;QAEA,OAAO,gBAAgB,CAAC,UAAU;QAClC,OAAO;YACL,OAAO,mBAAmB,CAAC,UAAU;QACvC;IACF,uDAAuD;IACvD,GAAG;QAAC;KAAmB;IAEvB,yEAAyE;IACzE,wDAAwD;IACxD,IAAI,QAAQ,CAAA,GAAA,eAAO;IACnB,OAAO,QAAQ;QAAC;KAAO,GAAG;AAC5B;AAEO,SAAS;IACd,OAAO,CAAA,GAAA,iBAAS,EAAE;AACpB","sources":["packages/@react-spectrum/utils/src/BreakpointProvider.tsx"],"sourcesContent":["import React, {ReactNode, useContext, useEffect, useState} from 'react';\nimport {useIsSSR} from '@react-aria/ssr';\n\ninterface Breakpoints {\n  S?: number,\n  M?: number,\n  L?: number,\n  [custom: string]: number | undefined\n}\n\ninterface BreakpointContext {\n  matchedBreakpoints: string[]\n}\n\nconst Context = React.createContext<BreakpointContext>(null);\nContext.displayName = 'BreakpointContext';\n\ninterface BreakpointProviderProps {\n  children?: ReactNode,\n  matchedBreakpoints: string[]\n}\n\nexport function BreakpointProvider(props: BreakpointProviderProps) {\n  let {\n    children,\n    matchedBreakpoints\n  } = props;\n  return (\n    <Context.Provider\n      value={{matchedBreakpoints}} >\n      {children}\n    </Context.Provider>\n  );\n}\n\nexport function useMatchedBreakpoints(breakpoints: Breakpoints): string[] {\n  let entries = Object.entries(breakpoints).sort(([, valueA], [, valueB]) => valueB - valueA);\n  let breakpointQueries = entries.map(([, value]) => `(min-width: ${value}px)`);\n\n  let supportsMatchMedia = typeof window !== 'undefined' && typeof window.matchMedia === 'function';\n  let getBreakpointHandler = () => {\n    let matched = [];\n    for (let i in breakpointQueries) {\n      let query = breakpointQueries[i];\n      if (window.matchMedia(query).matches) {\n        matched.push(entries[i][0]);\n      }\n    }\n    matched.push('base');\n    return matched;\n  };\n\n  let [breakpoint, setBreakpoint] = useState(() =>\n    supportsMatchMedia\n      ? getBreakpointHandler()\n      : ['base']\n  );\n\n  useEffect(() => {\n    if (!supportsMatchMedia) {\n      return;\n    }\n\n    let onResize = () => {\n      const breakpointHandler = getBreakpointHandler();\n\n      setBreakpoint(previousBreakpointHandler => {\n        if (previousBreakpointHandler.length !== breakpointHandler.length ||\n          previousBreakpointHandler.some((breakpoint, idx) => breakpoint !== breakpointHandler[idx])) {\n          return [...breakpointHandler]; // Return a new array to force state change\n        }\n\n        return previousBreakpointHandler;\n      });\n    };\n\n    window.addEventListener('resize', onResize);\n    return () => {\n      window.removeEventListener('resize', onResize);\n    };\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [supportsMatchMedia]);\n\n  // If in SSR, the media query should never match. Once the page hydrates,\n  // this will update and the real value will be returned.\n  let isSSR = useIsSSR();\n  return isSSR ? ['base'] : breakpoint;\n}\n\nexport function useBreakpoint(): BreakpointContext {\n  return useContext(Context);\n}\n"],"names":[],"version":3,"file":"BreakpointProvider.module.js.map"}